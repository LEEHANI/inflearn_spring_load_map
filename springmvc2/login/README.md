# 6. 로그인 처리1 - 쿠키, 세션

## 패키지 구조 설명 
- `도메인` 화면, UI, 기술 인프라 등등의 영역을 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역 
- 향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다.
- 이렇게 하려면 web은 domain을 알고있지만 domain은 web을 모르도록 설계해야 한다.
- web 패키지를 모두 삭제해도 domain에는 전혀 영향이 없도록 의존관계를 설계하는 것이 중요하다. 


# 로그인 처리하기 - 쿠키 사용 
- HTTP는 stateless이므로 쿠키로 사용자 정보를 저장한다. 
- 서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저에 전달하자. 그러면 `브라우저는 앞으로 해당 쿠키를 지속해서 보내준다.`

## 쿠키 종류
  + `영속 쿠키`: 만료 날짜를 입력하면 해당 날짜까지 유지
  + `세션 쿠키`: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

## 쿠키 동작 방식 
- 클라이언트가 사용자 정보 전달 
- 서버는 사용자가 맞는지 디비에서 확인 
- 서버에서 쿠키 생성 
- 서버는 클라이언트에 `Set-Cookie: memberId=1`로 쿠키에 담아서 전달 
- 사용자 쿠키 저장소에 `member=1` 저장
- 클라이언트는 요청시 항상 `Cookie: memberId=1`로 쿠키를 전달한다.

## 쿠키 생성 로직 
- ```java
  //쿠키에 시간 정보를 주지 않으면 세션 쿠키(브라우저 종료시 모두 종료)
  Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
  response.addCookie(idCookie);
  ```
- `@CoolieValue(name = "memberId")`로 컨트롤러에서 편리하게 쿠키를 조회할 수 있다. 

## 로그아웃 기능 
- 해당 쿠키의 종료 날짜를 0으로 지정 
- ```java
  Cookie cookie = new Cookie("memberId", null);
  cookie.setMaxAge(0);
  response.addCookie(cookie);
  ```

## 쿠키와 보안 문제 
- `쿠키의 값은 임의로 변경할 수 있다.`
  + 웹브라우저에서 쿠키 값을 강제로 변경하면, 다른 사용자가 될 수 있다. 
- `쿠키에 보관된 정보는 훔쳐갈 수 있다.` 
  + 쿠키에 개인정보나, 신용카드 정보가 있을 수 있다. 
  + 쿠키의 정보로 나의 로컬 PC가 털릴 수 있고, 네트워크 전송 구간에서 털릴 수 있다.
- `해커가 쿠키를 한 번 훔쳐가면 평생 사용할 수 있다.`
  + 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다. 

### 대안 
- 사용자별로 예측이 불가능한 임의의 토큰값을 노출하고, 서버에서 토큰을 관리한다.
- 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게 유지한다. 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다. 

# 로그인 처리하기 - 세션 동작 방식 
- 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라함. 
- 
## 세션 동작 방식
### 로그인
- 클라이언트가 사용자 정보 전달 
- 서버는 사용자가 맞는지 디비에서 확인 
- 추적이 불가능한 세션 ID를 생성. `MySessionId=zz0101023...`
- 생성된 세션 ID와 값을 서버의 `세션 저장소`에 보관. `sessionId=zz0101023..., value=memberA` 
- 서버는 클라이언트에 `mySessionId`라는 이름으로 세션ID만 쿠키에 담아서 전달. `Set-Cookie:mySessionId=zz0101023...` 
- 클라이언트는 요청시 항상 mySessionId 쿠키를 전달한다. `Cookie:mySessionId=zz0101023...` 
### 로그인 이후 
- 클라이언트는 요청시 항상 `mySessionId` 쿠키를 전달
- 서브는 클라이언트가 전달한 `mySessionId` 쿠키 정보로 로그인시 보관한 세션 저장소에서 세션 정보를 사용

## 세션 중요한 포인트 
- 클라이언트에게 회원과 관련된 정보를 전달하지 않는다. 
- `추척 불가능한 세션ID만 쿠키를 통해 클라이언트에게 전달한다.` 

## 세션과 보안 문제
- 세션을 사용하면 쿠키에서 발생했던 보안 문제를 해결할 수 있다. 
- 쿠키값 변조 가능 -> 예측 불가능한 복잡한 세션ID 사용 
- 쿠키 정보 해킹 -> 세션ID로는 중요한 정보를 알 수 없다. 
- 쿠키 탈취 후 사용 -> 세션의 만료 시간을 짧게 유지. 해킹이 의심되는 경우 세션을 강제로 제거 


# HttpSession
- 서블릿이 제공하는 HttpSession도 결국 우리가 만든 SessionManager와 같은 방식으로 동작함
- `서블릿을 통해 HttpSession을 생성하면 JSESSIONID라는 이름으로 쿠키가 생성되고, 값은 추정 불가능한 랜덤 값이다.` 
- `Cookie: JSESSIONID=5B78172AB2918D24J132`

## HttpSession 사용 
- ```
  //로그인 성공 
  //세션이 있으면 있는 세션 반환, 없으면 신규 세션 생성
  HttpSession session = request.getSession();
  //세션에 로그인 회원 정보 보관
  session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember);
  ```
- `request.getSession() == request.getSession(true)`
  + 세션이 있으면 있는 세션 반환, 없으면 신규 세션 생성
- `request.getSession(false)`
  + 세션이 있으면 있는 세션 반환, 없으면 신규 세션 생성안하고 null을 반환 
- `스프링은 세션을 더 편리하게 사용할 수 있도록 @SessionAttribute 을 지원한다.`
  + `@SessionAttribute(name = "loginMember", required = false) Member loginMember`
  + 이 기능은 세션을 생성하지 않는다.
- 세션은 사용자가 로그아웃을 직접 호출해서 `session.invalidate()` 가 호출 되는 경우에 삭제된다.

## 세션 종료 시점 
- 세션 종료 시간을 30분으로 잡아놨다고 가정해보자. 유저는 열심히 사이트를 돌아다니다가 30분 뒤에는 다시 로그인을 해야할 것이다. 
- 사용자가 서버에 마지막에 요청한 시간을 기준으로 30분 정도로 계속 연장시켜주면, 유저는 30분마다 로그인해야하는 번거로움이 사라진다.
- `HttpSession`은 이 방식을 사용한다. 
- 세션 타임아웃 설정은 application.properties에 `server.servlet.session.timeout=60`으로 설정 가능  

## 세션 주의사항 
- 세션에는 `최소한의 데이터만 보관`해야 한다. 
- 보관한 데이터 용량 * 사용자 수로 세션의 메모리 사용량이 급격하게 늘어나서 장애로 이어질 수 있다. 
- 추가로 `세션의 시간을 너무 길게 가져가면 메모리 사용이 계속 누적 될 수 있으므로 적당한 시간을 선택`하는 것이 필요하다. 

